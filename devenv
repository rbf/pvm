#!/bin/zsh

# parse install option to ln -s this to /usr/local/bin

set -o pipefail

DEVENV_VERSION='v0.1'

# Make arrays to be zero-based, as in bash.
setopt KSH_ARRAYS

DEVENV_FULL_PATH="${0:A}"
DEVENV_DIR="$(dirname "${DEVENV_FULL_PATH}")"
DEVENV_NAME="$(basename "${DEVENV_FULL_PATH}")"
INSTALL_DIR="/usr/local/bin"
INSTALL_FULL_PATH="${INSTALL_DIR}/${DEVENV_NAME}"

function print_help() {
  cat << EOF | less -FRXK
devenv ${DEVENV_VERSION}

    Setup and use local dev environments without installing them locally
    leveraging Docker to simulate the commands available normally for the
    given dev environment.

    Note that this currently only works for Zshell and in a Tmux session.


Usage:

  devenv command [options]


Available commands:

  install             Creates a simlink to /usr/local/bin and explains what else to do.

  list                List available environments.

      --all, -a             List all versions for each enviorment.
      --filter, -f string   List only the environments matching the given string.
      --verbose, -v         Include headers and base Docker image tag.
      --porcelain           Format in a machine readable way (i.e. csv).

  open string         Opens a new tmux window with the tools for the 'string' env.

  help                Print this help and exits.

EOF
}

function exit_with_error() {
  print -P "%F{1}ERROR${*+: }${*}%f" 1>&2
  print "Type 'devenv help' for more information." 1>&2
  exit 1
}

function exit_with_warn() {
  print -P "%F{3}${*:?missing warn message}%f"
  exit 1
}

function exit_with_success() {
  print -P "%F{2}SUCCESS${*+: }${*}%f"
  exit 0
}

function install() {
  if [ -f  "${INSTALL_FULL_PATH}" ]; then
    exit_with_warn "A file named '${DEVENV_NAME}' is already present in '${INSTALL_DIR}'. Nothing to do."
  fi
  ln -vs "${DEVENV_FULL_PATH}" "${INSTALL_FULL_PATH}" || exit_with_error
  cat << EOF
Now add the following line at the end of your .zshrc file:

  \$(devenv source \${__DEVENV_TARGET})

EOF
}

function list() {
  local is_porcelain=false
  local is_verbose=false
  local is_print_all_versions=false
  local filter_pattern='.*'
  while (( # > 0 )); do
    case "${1}" in
      --porcelain )
        shift
        is_porcelain=true
        ;;
      --verbose|-v )
        shift
        is_verbose=true
        ;;
      --all|-a )
        shift
        is_print_all_versions=true
        ;;
      --filter|-f )
        flag="${1}"
        shift
        if [ -n "${1}" ]; then
          filter_pattern="${1}"
          shift
        else
          exit_with_error "Missing value for '${flag}' flag"
        fi
        ;;
      * )
        exit_with_error "Unsupported option '${1}' for list command"
        ;;
    esac
  done

  function parse_env_versions() {
    unset image_tags tool_versions
    if ! versions="$(set -o pipefail; cat "${1}/versions" | grep -v '#')"; then
      exit_with_error "Unable to parse available versions from '${1}/versions'."
    fi
    # (f) Split the result of the expansion at newlines.
    # SOURCE: 17nov2021 https://zsh.sourceforge.io/Doc/Release/Expansion.html#Glob-Qualifiers
    for version in "${(f)versions}"; do
      image_tags+=("${version%%|*}")
      tool_versions+=("$(echo ${version} | sed '/|/!d;s/[^|]*|\(.*\)/\1/')")
      $is_print_all_versions || break
    done
    unset version versions
  }

  function image_tag() {
    $is_verbose && print -n "${image_tags[${i}]}${1}"
  }

  function tool_name() {
    grep '__DEVENV_SECONDARY_NAME' "${env_dir}/script" | cut -f 2 -d '=' | tr -d '"'"'" || print -- "${1}"
  }

  function env_version() {
    echo "${image_tags[${i}]}" | grep -oE '\d+\.\d+\.\d+'
  }

  function list_all() {
    for (( i = 0; i < ${#image_tags[@]}; i++ )); do
      if ((i == 0)); then
        print -n "*"
      else
        print -n " "
      fi
      print -n "|${env_name}|$(env_version)|"
      if $is_verbose; then
        print -- "$(tool_name '-')|${tool_versions[i]:--}|$(image_tag)"
      else
        print -- "$(tool_name) ${tool_versions[i]}"
      fi
    done
  }

  function list_porcelain() {
    for (( i = 0; i < ${#image_tags[@]}; i++ )); do
      print "${env_name};$(env_version);$(tool_name);${tool_versions[${i}]};$(image_tag ';')"
    done
  }

  if $is_verbose; then
    if $is_porcelain; then
      print "env;env version;tool;tool version;docker image tag;"
    else
      print " |Env|Env Version|Tool|Tool Version|Base Docker Image"
      print -- " |-----------|-----------|-----------|-----------|-----------"
    fi
  fi

  find "${DEVENV_DIR}/env" -type d -mindepth 1 -maxdepth 1 | sort | while read env_dir; do
    parse_env_versions "${env_dir}"
    env_name="$(basename ${env_dir})"
    $is_porcelain && list_porcelain || list_all | grep -- "${filter_pattern}"
  done
  unset env_dir env_name
}

function check_available_target_env_or_exit() {
  if ! [ -n "${1}" ]; then
    exit_with_error "Target env missing."
  fi

  TARGET_ENV_DIR="${DEVENV_DIR}/env/${1}"
  if ! [ -d "${TARGET_ENV_DIR}" ]; then
    exit_with_error "Target env '${1}' not found."
  fi
}

function source_target_env() {
  [ -n "${1}" ] || return
  check_available_target_env_or_exit "${1}"
  print "source ${DEVENV_DIR}/env/script"
}

function open_target_env() {
  if [ -z "${TMUX}" ]; then
    exit_with_error "${DEVENV_NAME} currently only works from within a tmux session."
  fi
  __DEVENV_TARGET="${1}"
  check_available_target_env_or_exit "${__DEVENV_TARGET}"
  if tmux new-window -n "${__DEVENV_TARGET} (devenv)" -e "IS_ALLOWED_TO_PRINT_LOGIN_GREETING=false" -e "__DEVENV_TARGET=${__DEVENV_TARGET}"; then
    exit_with_success "New tmux window opened for target env '${__DEVENV_TARGET}'."
  else
    exit_with_error "Unable to open a new tmux window for target env '${__DEVENV_TARGET}'."
  fi

}

function parse_commands_and_options() {
  while (( # > 0 )); do
    case "${1}" in
      install )
        shift
        install
        exit
        ;;
      list )
        shift
        list "${@}" | column -txs '|'
        exit
        ;;
      open )
        shift
        open_target_env "${@}"
        exit
        ;;
      source )
        shift
        source_target_env "${@}"
        exit
        ;;
      help|'' )
        shift
        print_help
        exit
        ;;
      * )
        exit_with_error "Unsupported option: '${1}'"
        ;;
    esac
  done
  print_help
}

parse_commands_and_options "${@}"

exit
