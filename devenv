#!/bin/zsh

# parse install option to ln -s this to /usr/local/bin

set -o pipefail

DEVENV_VERSION='v0.1'

# Make arrays to be zero-based, as in bash.
setopt KSH_ARRAYS

DEVENV_FULL_PATH="${0:A}"
DEVENV_DIR="$(dirname "${DEVENV_FULL_PATH}")"
DEVENV_NAME="$(basename "${DEVENV_FULL_PATH}")"
INSTALL_DIR="/usr/local/bin"
INSTALL_FULL_PATH="${INSTALL_DIR}/${DEVENV_NAME}"

function print_help() {
  cat << EOF
devenv ${DEVENV_VERSION}

    Setup and use local dev environments without installing them locally
    leveraging Docker to simulate the commands available normally for the
    given dev environment.

    Note that this currently only works for Zshell and in a Tmux session.


Usage:

  devenv command [options]


Available commands:

  install             Creates a simlink to /usr/local/bin and explains what else to do.

  list                List available environments.

      --all, -a             List all versions for each enviorment. Without this flag only the
                            default version for each environment is listed.
      --filter, -f string   List only the environments matching the given string.
      --verbose, -v         Include headers and base Docker image tag.
      --color, --no-color   Force or disable color formating. By default, on when sdtout is terminal
                            and off otherwise.
      --porcelain           Format in a machine readable way (i.e. csv).

  open string [version [tool-version]]
                      Opens a new tmux window with the tools for the 'string' env. By default it
                      opens the newest available version. Optionally, the environment and the
                      corresponding tool's versions (if present for that environment) can be
                      specified.

  help                Print this help and exits.

EOF
}

function exit_with_error() {
  print -P "%F{1}ERROR${*+: }${*}%f" 1>&2
  print "Type 'devenv help' for more information." 1>&2
  exit 1
}

function exit_with_warn() {
  print -P "%F{3}${*:?missing warn message}%f"
  exit 1
}

function exit_with_success() {
  print -P "%F{2}SUCCESS${*+: }${*}%f"
  exit 0
}

function install() {
  if [ -f  "${INSTALL_FULL_PATH}" ]; then
    exit_with_warn "A file named '${DEVENV_NAME}' is already present in '${INSTALL_DIR}'. Nothing to do."
  fi
  ln -vs "${DEVENV_FULL_PATH}" "${INSTALL_FULL_PATH}" || exit_with_error
  cat << EOF
Now add the following line at the end of your .zshrc file:

  \$(devenv source \${__DEVENV_TARGET})

EOF
}

function get_version_pattern() {
  case "${1}" in
    '' )
      return
      ;;
    *.*.[0-9]|*.*.[0-9][0-9]|*.*.[0-9][0-9][0-9] )
      print "${1//./\\\\.}"
      ;;
    *.[0-9]|*.[0-9][0-9]|*.[0-9][0-9][0-9] )
      print "${1//./\\\\.}\\\\.[0-9][0-9]*"
      ;;
    [0-9]|[0-9][0-9]|[0-9][0-9][0-9] )
      print "${1//./\\\\.}\\\\.[0-9][0-9]*\\\\.[0-9][0-9]*"
      ;;
    * )
      exit_with_error "Unrecognized version format: '${1}'"
      ;;
  esac
}

function env_version() {
  echo "${1:-${IMAGE_TAGS[${i}]}}" | grep -oE '\d+\.\d+\.\d+'
}

function parse_env_versions() {
  unset IMAGE_TAGS TOOL_VERSIONS
  if ! versions="$(set -o pipefail; cat "${1}/versions" | sed '/^\s*#/d;/^$/d')"; then
    exit_with_error "Unable to parse available versions from '${1}/versions'."
  fi

  # (f) Split the result of the expansion at newlines.
  # SOURCE: 17nov2021 https://zsh.sourceforge.io/Doc/Release/Expansion.html#Glob-Qualifiers
  for version in "${(f)versions}"; do
    found_versions=true
    IMAGE_TAGS+=("${version%%|*}")
    TOOL_VERSIONS+=("$(echo ${version} | sed '/|/!d;s/[^|]*|\(.*\)/\1/')")
    ${is_print_all_versions:-true} || break
  done
  unset version versions
}

function list() {
  local is_porcelain=false
  local is_verbose=false
  local is_print_all_versions=false
  local is_color_enabled=${is_sdtout_to_terminal}
  local filter_pattern='.*'
  while (( # > 0 )); do
    case "${1}" in
      --color )
        shift
        is_color_enabled=true
        ;;
      --no-color )
        shift
        is_color_enabled=false
        ;;
      --porcelain )
        shift
        is_porcelain=true
        ;;
      --verbose|-v )
        shift
        is_verbose=true
        ;;
      --all|-a )
        shift
        is_print_all_versions=true
        ;;
      --filter|-f )
        flag="${1}"
        shift
        if [ -n "${1}" ]; then
          filter_pattern="${1}"
          shift
        else
          exit_with_error "Missing value for '${flag}' flag"
        fi
        ;;
      * )
        exit_with_error "Unsupported option '${1}' for list command"
        ;;
    esac
  done

  function image_tag() {
    $is_verbose && print -n "${env_name}:${IMAGE_TAGS[${i}]}${1}"
  }

  function get_fg_for() {
    field="${1}"
    prev_field="prev_${1}"
    fg_field="fg_${1}"
    if [ "${(P)field}" = "${(P)prev_field}" ]; then
      typeset -g "${fg_field}=8"
    else
      typeset -g "${fg_field}=15"
    fi
    typeset -g "${prev_field}=${(P)field}"
  }

  function row_colored() {
    get_fg_for env_name
    get_fg_for env_version
    get_fg_for tool_name
    get_fg_for tool_version
    get_fg_for image_tag
    print -Pn "|%B%F{${fg_env_name}}${env_name}%f%b" \
              "|%B%F{${fg_env_version}}${env_version}%f%b|"
    if $is_verbose; then
      print -P -- "%F{${fg_tool_name}}${tool_name:--}%f" \
                  "|%F{${fg_tool_version}}${tool_version:--}%f" \
                  "|%F{${fg_image_tag}}${image_tag}%f"
    else
      print -P -- "%F{${fg_tool_name}}${tool_name}%f %F{${fg_tool_version}}${tool_version}%f"
    fi
  }

  function row_not_colored() {
    print -n "|${env_name}|${env_version}|"
    if $is_verbose; then
      print -- "${tool_name:--}|${tool_version:--}|${image_tag}"
    else
      print -- "${tool_name} ${tool_version}"
    fi
  }

  function list_human_friendly() {
    for (( i = 0; i < ${#IMAGE_TAGS[@]}; i++ )); do
      env_version="$(env_version)"
      tool_version="${TOOL_VERSIONS[i]}"
      image_tag="$(image_tag)"
      if ((i == 0)); then
        print -n "*"
      else
        print -n " "
      fi
      $is_color_enabled && row_colored || row_not_colored
    done
  }

  function list_porcelain() {
    for (( i = 0; i < ${#IMAGE_TAGS[@]}; i++ )); do
      print "${env_name};$(env_version);${tool_name};${TOOL_VERSIONS[${i}]};$(image_tag ';')"
    done
  }

  if $is_verbose; then
    if $is_porcelain; then
      print "env;env version;tool;tool version;docker image tag;"
    elif $is_color_enabled; then
      print -P " |%B%F{15}Env%f%b|%B%F{15}Env Version%f%b|%F{15}Tool%f|%F{15}Tool Version%f|%F{15}Base Docker Image%f"
      print -P -- " |%B%F{15}-----------%f%b|%B%F{15}-----------%f%b|%F{15}-----------%f|%F{15}-----------%f|%F{15}-----------%f"
    else
      print " |Env|Env Version|Tool|Tool Version|Base Docker Image"
      print -- " |-----------|-----------|-----------|-----------|-----------"
    fi
  fi

  find "${DEVENV_DIR}/env" -type d -mindepth 1 -maxdepth 1 | sort | while read env_dir; do
    parse_env_versions "${env_dir}"
    env_name="$(basename ${env_dir})"
    prev_env_name=""
    tool_name="$(grep '__DEVENV_SECONDARY_NAME' "${env_dir}/script" | cut -f 2 -d '=' | tr -d '"'"'")"
    prev_tool_name=""
    { $is_porcelain && list_porcelain || list_human_friendly } | grep -- "${filter_pattern}"
  done
  unset env_dir env_name prev_env_name
}

function check_available_target_env_or_exit() {
  if ! [ -n "${1}" ]; then
    exit_with_error "Target env missing."
  fi

  TARGET_ENV_DIR="${DEVENV_DIR}/env/${1}"
  if ! [ -d "${TARGET_ENV_DIR}" ]; then
    exit_with_error "Target env '${1}' not found."
  fi
}

function set_target_env_and_tool_versions_or_exit() {
  parse_env_versions "${TARGET_ENV_DIR}"

  if ! [ -n "${1}" ]; then
    __DEVENV_BASE_IMAGE_VERSION="${IMAGE_TAGS[0]}"
    __DEVENV_SECONDARY_VERSION="${TOOL_VERSIONS[0]}"
    return
  fi

  env_version_pattern="$(get_version_pattern "${1}")" || exit
  tool_version_pattern="$(get_version_pattern "${2}")" || exit

  local env_version
  local tool_version
  for (( i = 0; i < ${#IMAGE_TAGS[@]}; i++ )); do
    env_version="${IMAGE_TAGS[$i]}"
    tool_version="${TOOL_VERSIONS[$i]}"
    if [[ "${env_version}" =~ "(^|-)${env_version_pattern}" ]] && [[ "${tool_version}" =~ "^${tool_version_pattern}" ]]; then
      __DEVENV_BASE_IMAGE_VERSION="${env_version}"
      __DEVENV_SECONDARY_VERSION="${tool_version}"
      return
    fi
  done
  exit_with_error \
    "No available ${__DEVENV_TARGET} version matching '${1}'${2:+ with tool version "'"}${2}${2:+"'"}." \
    "Type 'devenv list -a -f ${__DEVENV_TARGET}' for a list of available ${__DEVENV_TARGET} versions."
}

function source_target_env() {
  [ -n "${1}" ] || return
  check_available_target_env_or_exit "${1}"
  print "source ${DEVENV_DIR}/env/script"
}

function open_target_env() {
  if [ -z "${TMUX}" ]; then
    exit_with_error "${DEVENV_NAME} currently only works from within a tmux session."
  fi
  __DEVENV_TARGET="${1}"
  check_available_target_env_or_exit "${__DEVENV_TARGET}"
  set_target_env_and_tool_versions_or_exit "${2}" "${3}"
  __DEVENV_ENV_VERSION="$(env_version "${__DEVENV_BASE_IMAGE_VERSION}")"
  env_name_and_version="${__DEVENV_TARGET} ${__DEVENV_ENV_VERSION}"
  if tmux new-window \
          -n "${env_name_and_version} (devenv)" \
          -e "IS_ALLOWED_TO_PRINT_LOGIN_GREETING=false" \
          -e "__DEVENV_TARGET=${__DEVENV_TARGET}" \
          -e "__DEVENV_ENV_VERSION=${__DEVENV_ENV_VERSION}" \
          -e "__DEVENV_BASE_IMAGE_VERSION=${__DEVENV_BASE_IMAGE_VERSION}" \
          -e "__DEVENV_SECONDARY_VERSION=${__DEVENV_SECONDARY_VERSION}"; then
    exit_with_success "New tmux window opened for ${env_name_and_version}."
  else
    exit_with_error "Unable to open a new tmux window for ${env_name_and_version}."
  fi

}

function parse_commands_and_options() {
  while (( # > 0 )); do
    case "${1}" in
      install )
        shift
        install
        exit
        ;;
      list )
        shift
        list "${@}" | column -txs '|'
        exit
        ;;
      open )
        shift
        open_target_env "${@}"
        exit
        ;;
      source )
        shift
        source_target_env "${@}"
        exit
        ;;
      help|'' )
        shift
        print_help
        exit
        ;;
      * )
        exit_with_error "Unsupported option: '${1}'"
        ;;
    esac
  done
  print_help
}

if [ -t 1 ]; then
  is_sdtout_to_terminal='true'
else
  is_sdtout_to_terminal='false'
fi

parse_commands_and_options "${@}"  | less -FRXK

exit
